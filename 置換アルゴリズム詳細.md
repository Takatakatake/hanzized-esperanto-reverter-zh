# 置換アルゴリズムの詳細説明

## 概要
このアプリケーションは**最長一致（Longest Match）アルゴリズム**を使用して、漢字化エスペラントをアルファベットに変換します。

## アルゴリズムの原理

### 1. 動的な最長エントリ長の計算
まず、辞書をロードする際に、全エントリの中で最も長い漢字列の長さを計算します：

```python
def create_kanji_to_esperanto_dict(df):
    kanji_dict = {}
    max_length = 0
    
    for _, row in df.iterrows():
        esperanto = str(row['esperanto']).strip()
        kanji = str(row['kanji']).strip()
        kanji_dict[kanji] = esperanto
        max_length = max(max_length, len(kanji))  # 最長を記録
    
    return kanji_dict, max_length
```

**現在のCSVの場合:**
- 最長エントリ長: **5文字**
- 分布:
  - 1文字: 1,359エントリ (47.4%)
  - 2文字: 1,332エントリ (46.5%)
  - 3文字: 144エントリ (5.0%)
  - 4文字: 27エントリ (0.9%)
  - 5文字: 2エントリ (0.07%)

### 2. 左から右へ走査、各位置で最長一致を探索

変換時は、テキストを左から右へ1文字ずつ走査し、各位置で以下の処理を行います：

```python
# 現在位置から最長エントリ長まで（長い→短い順）でチェック
for length in range(min(max_length, len(text) - i), 0, -1):
    substring = text[i:i+length]
    if substring in kanji_dict:
        result.append(kanji_dict[substring])
        i += length  # マッチした長さ分だけ進む
        found = True
        break  # 最長一致を採用
```

## 具体例で理解する

### 例1: 単純なケース
**入力:** "我听"

**処理:**
1. 位置0: "我听", "我" をチェック
   - "我听"は辞書にない
   - "我"は辞書にある → **mi** に変換、位置を1進める
2. 位置1: "听" をチェック
   - "听"は辞書にある → **aŭd** に変換

**出力:** "miaŭd" → 小文字化 → "miaŭd"

### 例2: 複合語のケース（重要！）
**入力:** "我们"

辞書には以下のエントリがある：
- "我们" → ni (2文字)
- "我" → mi (1文字)

**処理:**
1. 位置0: 最長5文字から順にチェック
   - "我们XXX" (5文字) - テキストが短いのでスキップ
   - "我们XX" (4文字) - テキストが短いのでスキップ
   - "我们X" (3文字) - テキストが短いのでスキップ
   - **"我们" (2文字) - 辞書にマッチ！ → ni に変換、位置を2進める**
   - "我" (1文字) - チェックせず（既に長い方でマッチ）

**出力:** "ni"

**もし短い方から先にチェックしていたら（誤った実装）:**
1. 位置0: "我" (1文字) をチェック → "mi" に変換
2. 位置1: "们" (1文字) をチェック → 辞書にない → そのまま
3. **誤った出力:** "mi们"

### 例3: 特殊文字を含むケース
**入力:** "人ʜoj"

辞書には以下のエントリがある：
- "人ʜ" → hom (2文字: 漢字1文字 + 特殊文字1文字)
- "人" → 単独では存在しない場合

**処理:**
1. 位置0: 最長5文字から順にチェック
   - "人ʜojXX" (5文字) - スキップ
   - "人ʜojX" (4文字) - スキップ
   - "人ʜoj" (3文字) - 辞書にない
   - **"人ʜ" (2文字) - 辞書にマッチ！ → hom に変換、位置を2進める**
2. 位置2: "oj" をチェック → アルファベットなのでそのまま保持

**出力:** "homoj" → 小文字化 → "homoj"

### 例4: 最長エントリ（5文字）のケース
**入力:** "建筑家ᴀᴋ"

辞書エントリ:
- "建筑家ᴀᴋ" → arkitekt (5文字)

**処理:**
1. 位置0: 最長5文字から順にチェック
   - **"建筑家ᴀᴋ" (5文字) - 辞書にマッチ！ → arkitekt に変換**

**出力:** "arkitekt"

## なぜ最長一致が必要か？

### 問題のシナリオ
もし**短い方から先に**チェックする誤った実装だと：

**入力:** "我们吃"

辞書:
- "我们" → ni
- "我" → mi
- "吃" → manĝ

**誤った処理（短い→長い）:**
1. "我" (1文字) をチェック → マッチ → "mi"
2. "们" (1文字) をチェック → マッチせず → "们"
3. "吃" (1文字) をチェック → マッチ → "manĝ"
4. **誤った出力:** "mi们manĝ"

**正しい処理（長い→短い）:**
1. "我们" (2文字) をチェック → マッチ → "ni"
2. "吃" (1文字) をチェック → マッチ → "manĝ"
3. **正しい出力:** "nimanĝ" → "nimanĝ"

## 性能の考慮

### 時間計算量
- 最悪の場合: O(n × m)
  - n: テキストの長さ
  - m: 最長エントリ長（現在は5）
- 実際には、ほとんどの文字が1-2文字でマッチするため、実質的にO(n)に近い

### 空間計算量
- O(k): 辞書のエントリ数（現在は2,864）

## まとめ

1. **動的に最長エントリ長を計算** → 辞書が変わっても対応可能
2. **各位置で長い方から短い方へ順にチェック** → 最長一致を保証
3. **最初にマッチしたものを採用** → 効率的な処理

このアルゴリズムにより、複合語や特殊文字を含むエントリも正しく処理できます。

---
作成日: 2025年10月2日
